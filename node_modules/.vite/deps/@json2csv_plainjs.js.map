{
  "version": 3,
  "sources": ["../../@json2csv/formatters/src/default.ts", "../../@json2csv/formatters/src/number.ts", "../../@json2csv/formatters/src/string.ts", "../../@json2csv/formatters/src/stringExcel.ts", "../../@json2csv/formatters/src/symbol.ts", "../../@json2csv/formatters/src/object.ts", "../../@json2csv/plainjs/src/utils.ts", "../../@json2csv/plainjs/src/BaseParser.ts", "../../@json2csv/plainjs/src/Parser.ts", "../../@streamparser/json/src/utils/utf-8.ts", "../../@streamparser/json/src/utils/bufferedString.ts", "../../@streamparser/json/src/utils/types/tokenType.ts", "../../@streamparser/json/src/tokenizer.ts", "../../@streamparser/json/src/utils/types/stackElement.ts", "../../@streamparser/json/src/tokenparser.ts", "../../@streamparser/json/dist/mjs/utils/types/jsonTypes.js", "../../@streamparser/json/src/utils/types/parsedTokenInfo.ts", "../../@streamparser/json/dist/mjs/utils/types/parsedElementInfo.js", "../../@json2csv/plainjs/src/StreamParser.ts"],
  "sourcesContent": ["export default function defaultFormatter<T>(value: T) {\n  if (value === null || value === undefined) return '';\n\n  return `${value}`;\n}\n", "import type Formatter from './Formatter.js';\n\nexport interface NumberFormatterOptions {\n  separator?: string;\n  decimals?: number;\n}\n\nexport default function numberFormatter<T extends number>(\n  opts: NumberFormatterOptions = {},\n): Formatter<T> {\n  const { separator, decimals } = opts;\n  if (separator) {\n    if (decimals) {\n      return (value) => value.toFixed(decimals).replace('.', separator);\n    }\n\n    return (value) => `${value}`.replace('.', separator);\n  }\n\n  if (decimals) {\n    return (value) => value.toFixed(decimals);\n  }\n\n  return (value) => `${value}`;\n}\n", "import type Formatter from './Formatter.js';\n\nexport interface StringFormatterOptions {\n  quote?: string;\n  escapedQuote?: string;\n}\n\nexport default function stringFormatter(\n  opts: StringFormatterOptions = {},\n): Formatter<string> {\n  const quote = typeof opts.quote === 'string' ? opts.quote : '\"';\n  const escapedQuote =\n    typeof opts.escapedQuote === 'string'\n      ? opts.escapedQuote\n      : `${quote}${quote}`;\n\n  if (!quote || quote === escapedQuote) {\n    return (value) => value;\n  }\n\n  const quoteRegExp = new RegExp(quote, 'g');\n  return (value) => {\n    if (value.includes(quote)) {\n      value = value.replace(quoteRegExp, escapedQuote);\n    }\n\n    return `${quote}${value}${quote}`;\n  };\n}\n", "const quote = '\"';\nconst escapedQuote = '\"\"\"\"';\n\nconst quoteRegExp = new RegExp(quote, 'g');\nexport default function stringExcel(value: string) {\n  return `\"=\"\"${value.replace(quoteRegExp, escapedQuote)}\"\"\"`;\n}\n", "import type Formatter from './Formatter.js';\nimport defaulStringFormatter from './string.js';\n\nexport default function symbolFormatter(\n  opts = { stringFormatter: defaulStringFormatter() },\n): Formatter<symbol> {\n  return (value) => opts.stringFormatter(value.toString().slice(7, -1));\n}\n", "import type Formatter from './Formatter.js';\nimport defaulStringFormatter from './string.js';\n\nexport default function objectFormatter<T extends object>(\n  opts = { stringFormatter: defaulStringFormatter() },\n): Formatter<T> {\n  return (value: T) => {\n    if (value === null) return '';\n\n    let stringifiedValue = JSON.stringify(value);\n\n    if (stringifiedValue === undefined) return '';\n\n    if (stringifiedValue[0] === '\"')\n      stringifiedValue = stringifiedValue.replace(/^\"(.+)\"$/, '$1');\n\n    return opts.stringFormatter(stringifiedValue);\n  };\n}\n", "type GetIndexedField<T, K> = K extends keyof T\n  ? T[K]\n  : K extends `${number}`\n    ? 'length' extends keyof T\n      ? number extends T['length']\n        ? number extends keyof T\n          ? T[number]\n          : undefined\n        : undefined\n      : undefined\n    : undefined;\n\ntype FieldWithPossiblyUndefined<T, Key> =\n  | GetFieldType<Exclude<T, undefined>, Key>\n  | Extract<T, undefined>;\n\ntype IndexedFieldWithPossiblyUndefined<T, Key> =\n  | GetIndexedField<Exclude<T, undefined>, Key>\n  | Extract<T, undefined>;\n\ntype GetFieldType<T, P> = P extends `${infer Left}.${infer Right}`\n  ? Left extends keyof Exclude<T, undefined>\n    ?\n        | FieldWithPossiblyUndefined<Exclude<T, undefined>[Left], Right>\n        | Extract<T, undefined>\n    : Left extends `${infer FieldKey}[${infer IndexKey}]`\n      ? FieldKey extends keyof T\n        ? FieldWithPossiblyUndefined<\n            IndexedFieldWithPossiblyUndefined<T[FieldKey], IndexKey>,\n            Right\n          >\n        : undefined\n      : undefined\n  : P extends keyof T\n    ? T[P]\n    : P extends `${infer FieldKey}[${infer IndexKey}]`\n      ? FieldKey extends keyof T\n        ? IndexedFieldWithPossiblyUndefined<T[FieldKey], IndexKey>\n        : undefined\n      : IndexedFieldWithPossiblyUndefined<T, P>;\n\ntype PropertyName = string | number | symbol;\n\nconst rePropName = RegExp(\n  // Match anything that isn't a dot or bracket.\n  '[^.[\\\\]]+' +\n    '|' +\n    // Or match property names within brackets.\n    '\\\\[(?:' +\n    // Match a non-string expression.\n    '([^\"\\'][^[]*)' +\n    '|' +\n    // Or match strings (supports escaping characters).\n    '([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' +\n    ')\\\\]' +\n    '|' +\n    // Or match \"\" as the space between consecutive dots or empty brackets.\n    '(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))',\n  'g',\n);\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath<TKey extends keyof TObject, TObject extends object>(\n  path: TKey,\n  obj: TObject,\n): [TKey];\nfunction castPath<TPath extends string, TObject>(\n  path: TPath,\n  obj: TObject,\n): Exclude<GetFieldType<TObject, TPath>, null | undefined>;\nfunction castPath(value: string): string[] {\n  const result: string[] = [];\n  let match: RegExpExecArray | null;\n  while ((match = rePropName.exec(value))) {\n    result.push(match[3] ?? match[1]?.trim() ?? match[0]);\n  }\n  return result;\n}\n\nexport function getProp<TObject extends object, TKey extends keyof TObject>(\n  obj: TObject,\n  path: TKey,\n  defaultValue: TObject[TKey],\n): TObject[TKey];\nexport function getProp<TObject, TPath extends string>(\n  obj: TObject,\n  path: TPath,\n): Exclude<GetFieldType<TObject, TPath>, null | undefined>;\nexport function getProp<\n  TObject,\n  TPath extends string,\n  TDefault = GetFieldType<TObject, TPath>,\n>(\n  obj: TObject,\n  path: TPath,\n  defaultValue: TDefault,\n): Exclude<GetFieldType<TObject, TPath>, null | undefined> | TDefault;\nexport function getProp<T>(\n  obj: any,\n  path: PropertyName,\n  defaultValue?: T,\n): T | undefined {\n  if (path in obj) {\n    const value = obj[path];\n    return value === undefined ? defaultValue : value;\n  }\n\n  const processedPath = Array.isArray(path) ? path : castPath(path, obj);\n  let currentValue = obj;\n  for (const key of processedPath) {\n    currentValue = currentValue?.[key];\n    if (currentValue === undefined) return defaultValue;\n  }\n  return currentValue;\n}\n\nexport function flattenReducer<T>(acc: Array<T>, arr: Array<T> | T): Array<T> {\n  try {\n    // This is faster but susceptible to `RangeError: Maximum call stack size exceeded`\n    Array.isArray(arr) ? acc.push(...arr) : acc.push(arr);\n    return acc;\n  } catch (err: unknown) {\n    // Fallback to a slower but safer option\n    return acc.concat(arr);\n  }\n}\n\nexport function fastJoin<T>(arr: Array<T>, separator: string): string {\n  let isFirst = true;\n  return arr.reduce((acc, elem) => {\n    if (elem === null || elem === undefined) {\n      elem = '' as T;\n    }\n\n    if (isFirst) {\n      isFirst = false;\n      return `${elem}`;\n    }\n\n    return `${acc}${separator}${elem}`;\n  }, '');\n}\n", "import {\n  type Formatter,\n  default as defaultFormatter,\n  number as numberFormatterCtor,\n  string as stringFormatterCtor,\n  symbol as symbolFormatterCtor,\n  object as objectFormatterCtor,\n} from '@json2csv/formatters';\nimport type Transform from './types/Transform.js';\nimport { getProp, flattenReducer, fastJoin } from './utils.js';\n\nexport interface FieldValueGetterInfo<FT> {\n  label: string;\n  default?: FT;\n}\n\nexport interface FieldValueGetterFnWithoutField<RT, FT> {\n  (row: RT): FT;\n}\n\nexport interface FieldValueGetterFnWithField<RT, FT> {\n  (row: RT, field: FieldValueGetterInfo<FT>): FT;\n}\n\nexport type FieldValueGetter<RT, FT> =\n  | string\n  | FieldValueGetterFnWithoutField<RT, FT>\n  | FieldValueGetterFnWithField<RT, FT>;\n\nexport interface FieldInfo<RT, FT> {\n  label?: string | undefined;\n  default?: FT | undefined;\n  value: FieldValueGetter<RT, FT>;\n}\n\nexport enum FormatterTypes {\n  header = 'header',\n  undefined = 'undefined',\n  boolean = 'boolean',\n  number = 'number',\n  bigint = 'bigint',\n  string = 'string',\n  symbol = 'symbol',\n  function = 'function',\n  object = 'object',\n}\n\nexport interface FormattersOptions {\n  [FormatterTypes.header]?: Formatter<string>;\n  [FormatterTypes.undefined]?: Formatter<undefined>;\n  [FormatterTypes.boolean]?: Formatter<boolean>;\n  [FormatterTypes.number]?: Formatter<number>;\n  [FormatterTypes.bigint]?: Formatter<bigint>;\n  [FormatterTypes.string]?: Formatter<string>;\n  [FormatterTypes.symbol]?: Formatter<symbol>;\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  [FormatterTypes.function]?: Formatter<Function>;\n  [FormatterTypes.object]?: Formatter<object>;\n}\n\nexport interface Json2CSVBaseOptions<TRaw, T> {\n  fields?: Array<string | FieldInfo<T, unknown>>;\n  ndjson?: boolean;\n  defaultValue?: string;\n  delimiter?: string;\n  eol?: string;\n  header?: boolean;\n  includeEmptyRows?: boolean;\n  withBOM?: boolean;\n  formatters?: FormattersOptions;\n  transforms?:\n    | []\n    | [Transform<TRaw, T>]\n    | [Transform<TRaw, any>, ...Array<Transform<any, any>>, Transform<any, T>];\n}\n\ninterface NormalizedFieldInfo<RT, FT> {\n  label: string;\n  value: FieldValueGetterFnWithoutField<RT, FT>;\n}\n\nexport interface NormalizedJson2CSVBaseOptions<TRaw, T>\n  extends Required<Json2CSVBaseOptions<TRaw, T>> {\n  fields: Array<NormalizedFieldInfo<T, unknown>>;\n  formatters: Required<FormattersOptions>;\n}\n\nexport default abstract class JSON2CSVBase<\n  TRaw extends object,\n  T extends object,\n> {\n  protected opts: NormalizedJson2CSVBaseOptions<TRaw, T>;\n\n  constructor(opts?: Readonly<Json2CSVBaseOptions<TRaw, T>>) {\n    this.opts = this.preprocessOpts(opts);\n  }\n\n  /**\n   * Check passing opts and set defaults.\n   *\n   * @param {Json2CsvOptions} opts Options object containing fields,\n   * delimiter, default value, header, etc.\n   */\n  protected preprocessOpts(\n    opts?: Json2CSVBaseOptions<TRaw, T>,\n  ): NormalizedJson2CSVBaseOptions<TRaw, T> {\n    const processedOpts = Object.assign(\n      {},\n      opts,\n    ) as NormalizedJson2CSVBaseOptions<TRaw, T>;\n\n    if (processedOpts.fields) {\n      processedOpts.fields = this.preprocessFieldsInfo(\n        processedOpts.fields,\n        processedOpts.defaultValue,\n      );\n    }\n\n    processedOpts.transforms = processedOpts.transforms || [];\n\n    const stringFormatter =\n      (processedOpts.formatters && processedOpts.formatters['string']) ||\n      stringFormatterCtor();\n    const objectFormatter = objectFormatterCtor({ stringFormatter });\n    const defaultFormatters = {\n      header: stringFormatter,\n      undefined: defaultFormatter,\n      boolean: defaultFormatter,\n      number: numberFormatterCtor(),\n      bigint: defaultFormatter,\n      string: stringFormatter,\n      symbol: symbolFormatterCtor({ stringFormatter }),\n      function: objectFormatter,\n      object: objectFormatter,\n    };\n\n    processedOpts.formatters = {\n      ...defaultFormatters,\n      ...processedOpts.formatters,\n    };\n\n    processedOpts.delimiter = processedOpts.delimiter || ',';\n    processedOpts.eol = processedOpts.eol || '\\n';\n    processedOpts.header = processedOpts.header !== false;\n    processedOpts.includeEmptyRows = processedOpts.includeEmptyRows || false;\n    processedOpts.withBOM = processedOpts.withBOM || false;\n\n    return processedOpts;\n  }\n\n  /**\n   * Check and normalize the fields configuration.\n   *\n   * @param {(string|object)[]} fields Fields configuration provided by the user\n   * or inferred from the data\n   * @returns {object[]} preprocessed FieldsInfo array\n   */\n  protected preprocessFieldsInfo(\n    fields: Array<string | FieldInfo<T, unknown>>,\n    globalDefaultValue?: string,\n  ): Array<NormalizedFieldInfo<T, unknown>> {\n    return fields.map((fieldInfo) => {\n      if (typeof fieldInfo === 'string') {\n        return {\n          label: fieldInfo,\n          value: (row) => getProp(row, fieldInfo, globalDefaultValue),\n        };\n      }\n\n      if (typeof fieldInfo === 'object') {\n        const defaultValue =\n          'default' in fieldInfo ? fieldInfo.default : globalDefaultValue;\n\n        if (typeof fieldInfo.value === 'string') {\n          const fieldPath: string = fieldInfo.value;\n          return {\n            label: fieldInfo.label || fieldInfo.value,\n            value: (row) => getProp(row, fieldPath, defaultValue),\n          };\n        }\n\n        if (typeof fieldInfo.value === 'function') {\n          const label = fieldInfo.label || fieldInfo.value.name || '';\n          const field = { label, default: defaultValue };\n          const valueGetter: FieldValueGetterFnWithField<T, unknown> =\n            fieldInfo.value;\n          return {\n            label,\n            value(row) {\n              const value = valueGetter(row, field);\n              return value === undefined ? defaultValue : value;\n            },\n          };\n        }\n      }\n\n      throw new Error(\n        'Invalid field info option. ' + JSON.stringify(fieldInfo),\n      );\n    });\n  }\n\n  /**\n   * Create the title row with all the provided fields as column headings\n   *\n   * @returns {String} titles as a string\n   */\n  protected getHeader(): string {\n    return fastJoin(\n      this.opts.fields.map((fieldInfo) =>\n        this.opts.formatters.header(fieldInfo.label),\n      ),\n      this.opts.delimiter,\n    );\n  }\n\n  /**\n   * Preprocess each object according to the given transforms (unwind, flatten, etc.).\n   * @param {Object} row JSON object to be converted in a CSV row\n   */\n  protected preprocessRow(row: TRaw): Array<T> {\n    return (this.opts.transforms as Array<Transform<any, any>>).reduce(\n      (rows: Array<unknown>, transform: Transform<any, any>) =>\n        rows.map((row) => transform(row)).reduce(flattenReducer, []),\n      [row],\n    ) as Array<T>;\n  }\n\n  /**\n   * Create the content of a specific CSV row\n   *\n   * @param {Object} row JSON object to be converted in a CSV row\n   * @returns {String} CSV string (row)\n   */\n  protected processRow(row: T): string | undefined {\n    if (!row) {\n      return undefined;\n    }\n\n    const processedRow = this.opts.fields.map((fieldInfo) =>\n      this.processCell(row, fieldInfo),\n    );\n\n    if (\n      !this.opts.includeEmptyRows &&\n      processedRow.every((field) => field === '')\n    ) {\n      return undefined;\n    }\n\n    return fastJoin(processedRow, this.opts.delimiter);\n  }\n\n  /**\n   * Create the content of a specfic CSV row cell\n   *\n   * @param {Object} row JSON object representing the  CSV row that the cell belongs to\n   * @param {FieldInfo} fieldInfo Details of the field to process to be a CSV cell\n   * @returns {String} CSV string (cell)\n   */\n  protected processCell<FT>(\n    row: T,\n    fieldInfo: NormalizedFieldInfo<T, FT>,\n  ): string {\n    return this.processValue<FT>(fieldInfo.value(row));\n  }\n\n  /**\n   * Create the content of a specfic CSV row cell\n   *\n   * @param {T} value Value to be included in a CSV cell\n   * @returns {String} Value stringified and processed\n   */\n\n  protected processValue<T>(value: T): string {\n    const formatter = this.opts.formatters[typeof value] as Formatter<T>;\n    return formatter(value);\n  }\n}\n", "import JSON2CSVBase, { type Json2CSVBaseOptions } from './BaseParser.js';\nimport { flattenReducer, fastJoin } from './utils.js';\n\nexport type ParserOptions<TRaw = object, T = TRaw> = Json2CSVBaseOptions<\n  TRaw,\n  T\n>;\n\nexport default class JSON2CSVParser<\n  TRaw extends object,\n  T extends object,\n> extends JSON2CSVBase<TRaw, T> {\n  constructor(opts?: Readonly<Omit<Json2CSVBaseOptions<TRaw, T>, 'ndjson'>>) {\n    super(opts);\n  }\n\n  /**\n   * Main function that converts json to csv.\n   *\n   * @param {Array|Object} data Array of JSON objects to be converted to CSV\n   * @returns {String} The CSV formated data as a string\n   */\n  parse(data: Array<TRaw> | TRaw): string {\n    const preprocessedData = this.preprocessData(data);\n\n    this.opts.fields =\n      this.opts.fields ||\n      this.preprocessFieldsInfo(\n        preprocessedData.reduce((fields: Array<string>, item) => {\n          Object.keys(item).forEach((field) => {\n            if (!fields.includes(field)) {\n              fields.push(field);\n            }\n          });\n\n          return fields;\n        }, []),\n        this.opts.defaultValue,\n      );\n\n    const header = this.opts.header ? this.getHeader() : '';\n    const rows = this.processData(preprocessedData);\n    const csv =\n      (this.opts.withBOM ? '\\ufeff' : '') +\n      header +\n      (header && rows ? this.opts.eol : '') +\n      rows;\n\n    return csv;\n  }\n\n  /**\n   * Preprocess the data according to the give opts (unwind, flatten, etc.)\n    and calculate the fields and field names if they are not provided.\n   *\n   * @param {Array|Object} data Array or object to be converted to CSV\n   */\n  preprocessData(data: Array<TRaw> | TRaw): Array<T> {\n    const processedData = Array.isArray(data) ? data : [data];\n\n    if (!this.opts.fields) {\n      if (data === undefined || data === null || processedData.length === 0) {\n        throw new Error(\n          'Data should not be empty or the \"fields\" option should be included',\n        );\n      }\n      if (typeof processedData[0] !== 'object') {\n        throw new Error(\n          'Data items should be objects or the \"fields\" option should be included',\n        );\n      }\n    }\n\n    if (this.opts.transforms.length === 0)\n      return processedData as unknown as Array<T>;\n\n    return processedData\n      .map((row) => this.preprocessRow(row))\n      .reduce(flattenReducer, []);\n  }\n\n  /**\n   * Create the content row by row below the header\n   *\n   * @param {Array} data Array of JSON objects to be converted to CSV\n   * @returns {String} CSV string (body)\n   */\n  processData(data: Array<T>): string {\n    return fastJoin(\n      data.map((row) => this.processRow(row)).filter((row) => row), // Filter empty rows\n      this.opts.eol,\n    );\n  }\n}\n", "export const enum charset {\n  BACKSPACE = 0x8, // \"\\b\"\n  FORM_FEED = 0xc, // \"\\f\"\n  NEWLINE = 0xa, // \"\\n\"\n  CARRIAGE_RETURN = 0xd, // \"\\r\"\n  TAB = 0x9, // \"\\t\"\n  SPACE = 0x20, //\n  EXCLAMATION_MARK = 0x21, // !\n  QUOTATION_MARK = 0x22, // \"\n  NUMBER_SIGN = 0x23, // #\n  DOLLAR_SIGN = 0x24, // $\n  PERCENT_SIGN = 0x25, // %\n  AMPERSAND = 0x26, // &\n  APOSTROPHE = 0x27, // '\n  LEFT_PARENTHESIS = 0x28, // (\n  RIGHT_PARENTHESIS = 0x29, // )\n  ASTERISK = 0x2a, // *\n  PLUS_SIGN = 0x2b, // +\n  COMMA = 0x2c, // ,\n  HYPHEN_MINUS = 0x2d, // -\n  FULL_STOP = 0x2e, // .\n  SOLIDUS = 0x2f, // /\n  DIGIT_ZERO = 0x30, // 0\n  DIGIT_ONE = 0x31, // 1\n  DIGIT_TWO = 0x32, // 2\n  DIGIT_THREE = 0x33, // 3\n  DIGIT_FOUR = 0x34, // 4\n  DIGIT_FIVE = 0x35, // 5\n  DIGIT_SIX = 0x36, // 6\n  DIGIT_SEVEN = 0x37, // 7\n  DIGIT_EIGHT = 0x38, // 8\n  DIGIT_NINE = 0x39, // 9\n  COLON = 0x3a, //  =\n  SEMICOLON = 0x3b, // ;\n  LESS_THAN_SIGN = 0x3c, // <\n  EQUALS_SIGN = 0x3d, // =\n  GREATER_THAN_SIGN = 0x3e, // >\n  QUESTION_MARK = 0x3f, // ?\n  COMMERCIAL_AT = 0x40, // @\n  LATIN_CAPITAL_LETTER_A = 0x41, // A\n  LATIN_CAPITAL_LETTER_B = 0x42, // B\n  LATIN_CAPITAL_LETTER_C = 0x43, // C\n  LATIN_CAPITAL_LETTER_D = 0x44, // D\n  LATIN_CAPITAL_LETTER_E = 0x45, // E\n  LATIN_CAPITAL_LETTER_F = 0x46, // F\n  LATIN_CAPITAL_LETTER_G = 0x47, // G\n  LATIN_CAPITAL_LETTER_H = 0x48, // H\n  LATIN_CAPITAL_LETTER_I = 0x49, // I\n  LATIN_CAPITAL_LETTER_J = 0x4a, // J\n  LATIN_CAPITAL_LETTER_K = 0x4b, // K\n  LATIN_CAPITAL_LETTER_L = 0x4c, // L\n  LATIN_CAPITAL_LETTER_M = 0x4d, // M\n  LATIN_CAPITAL_LETTER_N = 0x4e, // N\n  LATIN_CAPITAL_LETTER_O = 0x4f, // O\n  LATIN_CAPITAL_LETTER_P = 0x50, // P\n  LATIN_CAPITAL_LETTER_Q = 0x51, // Q\n  LATIN_CAPITAL_LETTER_R = 0x52, // R\n  LATIN_CAPITAL_LETTER_S = 0x53, // S\n  LATIN_CAPITAL_LETTER_T = 0x54, // T\n  LATIN_CAPITAL_LETTER_U = 0x55, // U\n  LATIN_CAPITAL_LETTER_V = 0x56, // V\n  LATIN_CAPITAL_LETTER_W = 0x57, // W\n  LATIN_CAPITAL_LETTER_X = 0x58, // X\n  LATIN_CAPITAL_LETTER_Y = 0x59, // Y\n  LATIN_CAPITAL_LETTER_Z = 0x5a, // Z\n  LEFT_SQUARE_BRACKET = 0x5b, // [\n  REVERSE_SOLIDUS = 0x5c, // \\\n  RIGHT_SQUARE_BRACKET = 0x5d, // ]\n  CIRCUMFLEX_ACCENT = 0x5e, // ^\n  LOW_LINE = 0x5f, // _\n  GRAVE_ACCENT = 0x60, // `\n  LATIN_SMALL_LETTER_A = 0x61, // a\n  LATIN_SMALL_LETTER_B = 0x62, // b\n  LATIN_SMALL_LETTER_C = 0x63, // c\n  LATIN_SMALL_LETTER_D = 0x64, // d\n  LATIN_SMALL_LETTER_E = 0x65, // e\n  LATIN_SMALL_LETTER_F = 0x66, // f\n  LATIN_SMALL_LETTER_G = 0x67, // g\n  LATIN_SMALL_LETTER_H = 0x68, // h\n  LATIN_SMALL_LETTER_I = 0x69, // i\n  LATIN_SMALL_LETTER_J = 0x6a, // j\n  LATIN_SMALL_LETTER_K = 0x6b, // k\n  LATIN_SMALL_LETTER_L = 0x6c, // l\n  LATIN_SMALL_LETTER_M = 0x6d, // m\n  LATIN_SMALL_LETTER_N = 0x6e, // n\n  LATIN_SMALL_LETTER_O = 0x6f, // o\n  LATIN_SMALL_LETTER_P = 0x70, // p\n  LATIN_SMALL_LETTER_Q = 0x71, // q\n  LATIN_SMALL_LETTER_R = 0x72, // r\n  LATIN_SMALL_LETTER_S = 0x73, // s\n  LATIN_SMALL_LETTER_T = 0x74, // t\n  LATIN_SMALL_LETTER_U = 0x75, // u\n  LATIN_SMALL_LETTER_V = 0x76, // v\n  LATIN_SMALL_LETTER_W = 0x77, // w\n  LATIN_SMALL_LETTER_X = 0x78, // x\n  LATIN_SMALL_LETTER_Y = 0x79, // y\n  LATIN_SMALL_LETTER_Z = 0x7a, // z\n  LEFT_CURLY_BRACKET = 0x7b, // {\n  VERTICAL_LINE = 0x7c, // |\n  RIGHT_CURLY_BRACKET = 0x7d, // }\n  TILDE = 0x7e, // ~\n}\n\nexport const escapedSequences: { [key: number]: number } = {\n  [charset.QUOTATION_MARK]: charset.QUOTATION_MARK,\n  [charset.REVERSE_SOLIDUS]: charset.REVERSE_SOLIDUS,\n  [charset.SOLIDUS]: charset.SOLIDUS,\n  [charset.LATIN_SMALL_LETTER_B]: charset.BACKSPACE,\n  [charset.LATIN_SMALL_LETTER_F]: charset.FORM_FEED,\n  [charset.LATIN_SMALL_LETTER_N]: charset.NEWLINE,\n  [charset.LATIN_SMALL_LETTER_R]: charset.CARRIAGE_RETURN,\n  [charset.LATIN_SMALL_LETTER_T]: charset.TAB,\n};\n", "export interface StringBuilder {\n  byteLength: number;\n  appendChar: (char: number) => void;\n  appendBuf: (buf: Uint8Array, start?: number, end?: number) => void;\n  reset: () => void;\n  toString: () => string;\n}\n\nexport class NonBufferedString implements StringBuilder {\n  private decoder = new TextDecoder(\"utf-8\");\n  private strings: string[] = [];\n  public byteLength = 0;\n\n  public appendChar(char: number): void {\n    this.strings.push(String.fromCharCode(char));\n    this.byteLength += 1;\n  }\n\n  public appendBuf(buf: Uint8Array, start = 0, end: number = buf.length): void {\n    this.strings.push(this.decoder.decode(buf.subarray(start, end)));\n    this.byteLength += end - start;\n  }\n\n  public reset(): void {\n    this.strings = [];\n    this.byteLength = 0;\n  }\n\n  public toString(): string {\n    return this.strings.join(\"\");\n  }\n}\n\nexport class BufferedString implements StringBuilder {\n  private decoder = new TextDecoder(\"utf-8\");\n  private buffer: Uint8Array;\n  private bufferOffset = 0;\n  private string = \"\";\n  public byteLength = 0;\n\n  public constructor(bufferSize: number) {\n    this.buffer = new Uint8Array(bufferSize);\n  }\n\n  public appendChar(char: number): void {\n    if (this.bufferOffset >= this.buffer.length) this.flushStringBuffer();\n    this.buffer[this.bufferOffset++] = char;\n    this.byteLength += 1;\n  }\n\n  public appendBuf(buf: Uint8Array, start = 0, end: number = buf.length): void {\n    const size = end - start;\n    if (this.bufferOffset + size > this.buffer.length) this.flushStringBuffer();\n    this.buffer.set(buf.subarray(start, end), this.bufferOffset);\n    this.bufferOffset += size;\n    this.byteLength += size;\n  }\n\n  private flushStringBuffer(): void {\n    this.string += this.decoder.decode(\n      this.buffer.subarray(0, this.bufferOffset),\n    );\n    this.bufferOffset = 0;\n  }\n\n  public reset(): void {\n    this.string = \"\";\n    this.bufferOffset = 0;\n    this.byteLength = 0;\n  }\n  public toString(): string {\n    this.flushStringBuffer();\n    return this.string;\n  }\n}\n", "enum TokenType {\n  LEFT_BRACE,\n  RIGHT_BRACE,\n  LEFT_BRACKET,\n  RIGHT_BRACKET,\n  COLON,\n  COMMA,\n  TRUE,\n  FALSE,\n  NULL,\n  STRING,\n  NUMBER,\n  SEPARATOR,\n}\n\nexport default TokenType;\n", "import { charset, escapedSequences } from \"./utils/utf-8.js\";\nimport {\n  type StringBuilder,\n  NonBufferedString,\n  BufferedString,\n} from \"./utils/bufferedString.js\";\nimport TokenType from \"./utils/types/tokenType.js\";\nimport type { ParsedTokenInfo } from \"./utils/types/parsedTokenInfo.js\";\n\n// Tokenizer States\nconst enum TokenizerStates {\n  START,\n  ENDED,\n  ERROR,\n  TRUE1,\n  TRUE2,\n  TRUE3,\n  FALSE1,\n  FALSE2,\n  FALSE3,\n  FALSE4,\n  NULL1,\n  NULL2,\n  NULL3,\n  STRING_DEFAULT,\n  STRING_AFTER_BACKSLASH,\n  STRING_UNICODE_DIGIT_1,\n  STRING_UNICODE_DIGIT_2,\n  STRING_UNICODE_DIGIT_3,\n  STRING_UNICODE_DIGIT_4,\n  STRING_INCOMPLETE_CHAR,\n  NUMBER_AFTER_INITIAL_MINUS,\n  NUMBER_AFTER_INITIAL_ZERO,\n  NUMBER_AFTER_INITIAL_NON_ZERO,\n  NUMBER_AFTER_FULL_STOP,\n  NUMBER_AFTER_DECIMAL,\n  NUMBER_AFTER_E,\n  NUMBER_AFTER_E_AND_SIGN,\n  NUMBER_AFTER_E_AND_DIGIT,\n  SEPARATOR,\n  BOM_OR_START,\n  BOM,\n}\n\nfunction TokenizerStateToString(tokenizerState: TokenizerStates): string {\n  return [\n    \"START\",\n    \"ENDED\",\n    \"ERROR\",\n    \"TRUE1\",\n    \"TRUE2\",\n    \"TRUE3\",\n    \"FALSE1\",\n    \"FALSE2\",\n    \"FALSE3\",\n    \"FALSE4\",\n    \"NULL1\",\n    \"NULL2\",\n    \"NULL3\",\n    \"STRING_DEFAULT\",\n    \"STRING_AFTER_BACKSLASH\",\n    \"STRING_UNICODE_DIGIT_1\",\n    \"STRING_UNICODE_DIGIT_2\",\n    \"STRING_UNICODE_DIGIT_3\",\n    \"STRING_UNICODE_DIGIT_4\",\n    \"STRING_INCOMPLETE_CHAR\",\n    \"NUMBER_AFTER_INITIAL_MINUS\",\n    \"NUMBER_AFTER_INITIAL_ZERO\",\n    \"NUMBER_AFTER_INITIAL_NON_ZERO\",\n    \"NUMBER_AFTER_FULL_STOP\",\n    \"NUMBER_AFTER_DECIMAL\",\n    \"NUMBER_AFTER_E\",\n    \"NUMBER_AFTER_E_AND_SIGN\",\n    \"NUMBER_AFTER_E_AND_DIGIT\",\n    \"SEPARATOR\",\n    \"BOM_OR_START\",\n    \"BOM\",\n  ][tokenizerState];\n}\n\nexport interface TokenizerOptions {\n  stringBufferSize?: number;\n  numberBufferSize?: number;\n  separator?: string;\n  emitPartialTokens?: boolean;\n}\n\nconst defaultOpts: TokenizerOptions = {\n  stringBufferSize: 0,\n  numberBufferSize: 0,\n  separator: undefined,\n  emitPartialTokens: false,\n};\n\nexport class TokenizerError extends Error {\n  constructor(message: string) {\n    super(message);\n    // Typescript is broken. This is a workaround\n    Object.setPrototypeOf(this, TokenizerError.prototype);\n  }\n}\n\nexport default class Tokenizer {\n  private state = TokenizerStates.BOM_OR_START;\n\n  private bom?: number[];\n  private bomIndex = 0;\n\n  private emitPartialTokens: boolean;\n  private separator?: string;\n  private separatorBytes?: Uint8Array;\n  private separatorIndex = 0;\n  private bufferedString: StringBuilder;\n  private bufferedNumber: StringBuilder;\n\n  private unicode?: string; // unicode escapes\n  private highSurrogate?: number;\n  private bytes_remaining = 0; // number of bytes remaining in multi byte utf8 char to read after split boundary\n  private bytes_in_sequence = 0; // bytes in multi byte utf8 char to read\n  private char_split_buffer = new Uint8Array(4); // for rebuilding chars split before boundary is reached\n  private encoder = new TextEncoder();\n  private offset = -1;\n\n  constructor(opts?: TokenizerOptions) {\n    opts = { ...defaultOpts, ...opts };\n\n    this.emitPartialTokens = opts.emitPartialTokens === true;\n    this.bufferedString =\n      opts.stringBufferSize && opts.stringBufferSize > 4\n        ? new BufferedString(opts.stringBufferSize)\n        : new NonBufferedString();\n    this.bufferedNumber =\n      opts.numberBufferSize && opts.numberBufferSize > 0\n        ? new BufferedString(opts.numberBufferSize)\n        : new NonBufferedString();\n\n    this.separator = opts.separator;\n    this.separatorBytes = opts.separator\n      ? this.encoder.encode(opts.separator)\n      : undefined;\n  }\n\n  public get isEnded(): boolean {\n    return this.state === TokenizerStates.ENDED;\n  }\n\n  public write(input: Iterable<number> | string): void {\n    try {\n      let buffer: Uint8Array;\n      if (input instanceof Uint8Array) {\n        buffer = input;\n      } else if (typeof input === \"string\") {\n        buffer = this.encoder.encode(input);\n      } else if (Array.isArray(input)) {\n        buffer = Uint8Array.from(input);\n      } else if (ArrayBuffer.isView(input)) {\n        buffer = new Uint8Array(\n          input.buffer,\n          input.byteOffset,\n          input.byteLength,\n        );\n      } else {\n        throw new TypeError(\n          \"Unexpected type. The `write` function only accepts Arrays, TypedArrays and Strings.\",\n        );\n      }\n\n      for (let i = 0; i < buffer.length; i += 1) {\n        const n = buffer[i]; // get current byte from buffer\n        switch (this.state) {\n          // @ts-ignore fall through case\n          case TokenizerStates.BOM_OR_START:\n            if (input instanceof Uint8Array && n === 0xef) {\n              this.bom = [0xef, 0xbb, 0xbf];\n              this.bomIndex += 1;\n              this.state = TokenizerStates.BOM;\n              continue;\n            }\n\n            if (input instanceof Uint16Array) {\n              if (n === 0xfe) {\n                this.bom = [0xfe, 0xff];\n                this.bomIndex += 1;\n                this.state = TokenizerStates.BOM;\n                continue;\n              }\n              if (n === 0xff) {\n                this.bom = [0xff, 0xfe];\n                this.bomIndex += 1;\n                this.state = TokenizerStates.BOM;\n                continue;\n              }\n            }\n\n            if (input instanceof Uint32Array) {\n              if (n === 0x00) {\n                this.bom = [0x00, 0x00, 0xfe, 0xff];\n                this.bomIndex += 1;\n                this.state = TokenizerStates.BOM;\n                continue;\n              }\n              if (n === 0xff) {\n                this.bom = [0xff, 0xfe, 0x00, 0x00];\n                this.bomIndex += 1;\n                this.state = TokenizerStates.BOM;\n                continue;\n              }\n            }\n          // Allow cascading\n          case TokenizerStates.START:\n            this.offset += 1;\n\n            if (this.separatorBytes && n === this.separatorBytes[0]) {\n              if (this.separatorBytes.length === 1) {\n                this.state = TokenizerStates.START;\n                this.onToken({\n                  token: TokenType.SEPARATOR,\n                  value: this.separator as string,\n                  offset: this.offset + this.separatorBytes.length - 1,\n                });\n                continue;\n              }\n              this.state = TokenizerStates.SEPARATOR;\n              continue;\n            }\n\n            if (\n              n === charset.SPACE ||\n              n === charset.NEWLINE ||\n              n === charset.CARRIAGE_RETURN ||\n              n === charset.TAB\n            ) {\n              // whitespace\n              continue;\n            }\n\n            if (n === charset.LEFT_CURLY_BRACKET) {\n              this.onToken({\n                token: TokenType.LEFT_BRACE,\n                value: \"{\",\n                offset: this.offset,\n              });\n              continue;\n            }\n            if (n === charset.RIGHT_CURLY_BRACKET) {\n              this.onToken({\n                token: TokenType.RIGHT_BRACE,\n                value: \"}\",\n                offset: this.offset,\n              });\n              continue;\n            }\n            if (n === charset.LEFT_SQUARE_BRACKET) {\n              this.onToken({\n                token: TokenType.LEFT_BRACKET,\n                value: \"[\",\n                offset: this.offset,\n              });\n              continue;\n            }\n            if (n === charset.RIGHT_SQUARE_BRACKET) {\n              this.onToken({\n                token: TokenType.RIGHT_BRACKET,\n                value: \"]\",\n                offset: this.offset,\n              });\n              continue;\n            }\n            if (n === charset.COLON) {\n              this.onToken({\n                token: TokenType.COLON,\n                value: \":\",\n                offset: this.offset,\n              });\n              continue;\n            }\n            if (n === charset.COMMA) {\n              this.onToken({\n                token: TokenType.COMMA,\n                value: \",\",\n                offset: this.offset,\n              });\n              continue;\n            }\n\n            if (n === charset.LATIN_SMALL_LETTER_T) {\n              this.state = TokenizerStates.TRUE1;\n              continue;\n            }\n\n            if (n === charset.LATIN_SMALL_LETTER_F) {\n              this.state = TokenizerStates.FALSE1;\n              continue;\n            }\n\n            if (n === charset.LATIN_SMALL_LETTER_N) {\n              this.state = TokenizerStates.NULL1;\n              continue;\n            }\n\n            if (n === charset.QUOTATION_MARK) {\n              this.bufferedString.reset();\n              this.state = TokenizerStates.STRING_DEFAULT;\n              continue;\n            }\n\n            if (n >= charset.DIGIT_ONE && n <= charset.DIGIT_NINE) {\n              this.bufferedNumber.reset();\n              this.bufferedNumber.appendChar(n);\n              this.state = TokenizerStates.NUMBER_AFTER_INITIAL_NON_ZERO;\n              continue;\n            }\n\n            if (n === charset.DIGIT_ZERO) {\n              this.bufferedNumber.reset();\n              this.bufferedNumber.appendChar(n);\n              this.state = TokenizerStates.NUMBER_AFTER_INITIAL_ZERO;\n              continue;\n            }\n\n            if (n === charset.HYPHEN_MINUS) {\n              this.bufferedNumber.reset();\n              this.bufferedNumber.appendChar(n);\n              this.state = TokenizerStates.NUMBER_AFTER_INITIAL_MINUS;\n              continue;\n            }\n\n            break;\n          // STRING\n          case TokenizerStates.STRING_DEFAULT:\n            if (n === charset.QUOTATION_MARK) {\n              const string = this.bufferedString.toString();\n              this.state = TokenizerStates.START;\n              this.onToken({\n                token: TokenType.STRING,\n                value: string,\n                offset: this.offset,\n              });\n              this.offset += this.bufferedString.byteLength + 1;\n              continue;\n            }\n\n            if (n === charset.REVERSE_SOLIDUS) {\n              this.state = TokenizerStates.STRING_AFTER_BACKSLASH;\n              continue;\n            }\n\n            if (n >= 128) {\n              // Parse multi byte (>=128) chars one at a time\n              if (n >= 194 && n <= 223) {\n                this.bytes_in_sequence = 2;\n              } else if (n <= 239) {\n                this.bytes_in_sequence = 3;\n              } else {\n                this.bytes_in_sequence = 4;\n              }\n\n              if (this.bytes_in_sequence <= buffer.length - i) {\n                // if bytes needed to complete char fall outside buffer length, we have a boundary split\n                this.bufferedString.appendBuf(\n                  buffer,\n                  i,\n                  i + this.bytes_in_sequence,\n                );\n                i += this.bytes_in_sequence - 1;\n                continue;\n              }\n\n              this.bytes_remaining = i + this.bytes_in_sequence - buffer.length;\n              this.char_split_buffer.set(buffer.subarray(i));\n              i = buffer.length - 1;\n              this.state = TokenizerStates.STRING_INCOMPLETE_CHAR;\n              continue;\n            }\n\n            if (n >= charset.SPACE) {\n              this.bufferedString.appendChar(n);\n              continue;\n            }\n\n            break;\n          case TokenizerStates.STRING_INCOMPLETE_CHAR:\n            // check for carry over of a multi byte char split between data chunks\n            // & fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration\n            this.char_split_buffer.set(\n              buffer.subarray(i, i + this.bytes_remaining),\n              this.bytes_in_sequence - this.bytes_remaining,\n            );\n            this.bufferedString.appendBuf(\n              this.char_split_buffer,\n              0,\n              this.bytes_in_sequence,\n            );\n            i = this.bytes_remaining - 1;\n            this.state = TokenizerStates.STRING_DEFAULT;\n            continue;\n          case TokenizerStates.STRING_AFTER_BACKSLASH:\n            const controlChar = escapedSequences[n];\n            if (controlChar) {\n              this.bufferedString.appendChar(controlChar);\n              this.state = TokenizerStates.STRING_DEFAULT;\n              continue;\n            }\n\n            if (n === charset.LATIN_SMALL_LETTER_U) {\n              this.unicode = \"\";\n              this.state = TokenizerStates.STRING_UNICODE_DIGIT_1;\n              continue;\n            }\n\n            break;\n          case TokenizerStates.STRING_UNICODE_DIGIT_1:\n          case TokenizerStates.STRING_UNICODE_DIGIT_2:\n          case TokenizerStates.STRING_UNICODE_DIGIT_3:\n            if (\n              (n >= charset.DIGIT_ZERO && n <= charset.DIGIT_NINE) ||\n              (n >= charset.LATIN_CAPITAL_LETTER_A &&\n                n <= charset.LATIN_CAPITAL_LETTER_F) ||\n              (n >= charset.LATIN_SMALL_LETTER_A &&\n                n <= charset.LATIN_SMALL_LETTER_F)\n            ) {\n              this.unicode += String.fromCharCode(n);\n              this.state += 1;\n              continue;\n            }\n            break;\n          case TokenizerStates.STRING_UNICODE_DIGIT_4:\n            if (\n              (n >= charset.DIGIT_ZERO && n <= charset.DIGIT_NINE) ||\n              (n >= charset.LATIN_CAPITAL_LETTER_A &&\n                n <= charset.LATIN_CAPITAL_LETTER_F) ||\n              (n >= charset.LATIN_SMALL_LETTER_A &&\n                n <= charset.LATIN_SMALL_LETTER_F)\n            ) {\n              const intVal = parseInt(\n                this.unicode + String.fromCharCode(n),\n                16,\n              );\n              if (this.highSurrogate === undefined) {\n                if (intVal >= 0xd800 && intVal <= 0xdbff) {\n                  //<55296,56319> - highSurrogate\n                  this.highSurrogate = intVal;\n                } else {\n                  this.bufferedString.appendBuf(\n                    this.encoder.encode(String.fromCharCode(intVal)),\n                  );\n                }\n              } else {\n                if (intVal >= 0xdc00 && intVal <= 0xdfff) {\n                  //<56320,57343> - lowSurrogate\n                  this.bufferedString.appendBuf(\n                    this.encoder.encode(\n                      String.fromCharCode(this.highSurrogate, intVal),\n                    ),\n                  );\n                } else {\n                  this.bufferedString.appendBuf(\n                    this.encoder.encode(\n                      String.fromCharCode(this.highSurrogate),\n                    ),\n                  );\n                }\n                this.highSurrogate = undefined;\n              }\n              this.state = TokenizerStates.STRING_DEFAULT;\n              continue;\n            }\n            break;\n          // Number\n          case TokenizerStates.NUMBER_AFTER_INITIAL_MINUS:\n            if (n === charset.DIGIT_ZERO) {\n              this.bufferedNumber.appendChar(n);\n              this.state = TokenizerStates.NUMBER_AFTER_INITIAL_ZERO;\n              continue;\n            }\n\n            if (n >= charset.DIGIT_ONE && n <= charset.DIGIT_NINE) {\n              this.bufferedNumber.appendChar(n);\n              this.state = TokenizerStates.NUMBER_AFTER_INITIAL_NON_ZERO;\n              continue;\n            }\n\n            break;\n          case TokenizerStates.NUMBER_AFTER_INITIAL_ZERO:\n            if (n === charset.FULL_STOP) {\n              this.bufferedNumber.appendChar(n);\n              this.state = TokenizerStates.NUMBER_AFTER_FULL_STOP;\n              continue;\n            }\n\n            if (\n              n === charset.LATIN_SMALL_LETTER_E ||\n              n === charset.LATIN_CAPITAL_LETTER_E\n            ) {\n              this.bufferedNumber.appendChar(n);\n              this.state = TokenizerStates.NUMBER_AFTER_E;\n              continue;\n            }\n\n            i -= 1;\n            this.state = TokenizerStates.START;\n            this.emitNumber();\n            continue;\n          case TokenizerStates.NUMBER_AFTER_INITIAL_NON_ZERO:\n            if (n >= charset.DIGIT_ZERO && n <= charset.DIGIT_NINE) {\n              this.bufferedNumber.appendChar(n);\n              continue;\n            }\n\n            if (n === charset.FULL_STOP) {\n              this.bufferedNumber.appendChar(n);\n              this.state = TokenizerStates.NUMBER_AFTER_FULL_STOP;\n              continue;\n            }\n\n            if (\n              n === charset.LATIN_SMALL_LETTER_E ||\n              n === charset.LATIN_CAPITAL_LETTER_E\n            ) {\n              this.bufferedNumber.appendChar(n);\n              this.state = TokenizerStates.NUMBER_AFTER_E;\n              continue;\n            }\n\n            i -= 1;\n            this.state = TokenizerStates.START;\n            this.emitNumber();\n            continue;\n          case TokenizerStates.NUMBER_AFTER_FULL_STOP:\n            if (n >= charset.DIGIT_ZERO && n <= charset.DIGIT_NINE) {\n              this.bufferedNumber.appendChar(n);\n              this.state = TokenizerStates.NUMBER_AFTER_DECIMAL;\n              continue;\n            }\n\n            break;\n          case TokenizerStates.NUMBER_AFTER_DECIMAL:\n            if (n >= charset.DIGIT_ZERO && n <= charset.DIGIT_NINE) {\n              this.bufferedNumber.appendChar(n);\n              continue;\n            }\n\n            if (\n              n === charset.LATIN_SMALL_LETTER_E ||\n              n === charset.LATIN_CAPITAL_LETTER_E\n            ) {\n              this.bufferedNumber.appendChar(n);\n              this.state = TokenizerStates.NUMBER_AFTER_E;\n              continue;\n            }\n\n            i -= 1;\n            this.state = TokenizerStates.START;\n            this.emitNumber();\n            continue;\n          // @ts-ignore fall through case\n          case TokenizerStates.NUMBER_AFTER_E:\n            if (n === charset.PLUS_SIGN || n === charset.HYPHEN_MINUS) {\n              this.bufferedNumber.appendChar(n);\n              this.state = TokenizerStates.NUMBER_AFTER_E_AND_SIGN;\n              continue;\n            }\n          // Allow cascading\n          case TokenizerStates.NUMBER_AFTER_E_AND_SIGN:\n            if (n >= charset.DIGIT_ZERO && n <= charset.DIGIT_NINE) {\n              this.bufferedNumber.appendChar(n);\n              this.state = TokenizerStates.NUMBER_AFTER_E_AND_DIGIT;\n              continue;\n            }\n\n            break;\n          case TokenizerStates.NUMBER_AFTER_E_AND_DIGIT:\n            if (n >= charset.DIGIT_ZERO && n <= charset.DIGIT_NINE) {\n              this.bufferedNumber.appendChar(n);\n              continue;\n            }\n\n            i -= 1;\n            this.state = TokenizerStates.START;\n            this.emitNumber();\n            continue;\n          // TRUE\n          case TokenizerStates.TRUE1:\n            if (n === charset.LATIN_SMALL_LETTER_R) {\n              this.state = TokenizerStates.TRUE2;\n              continue;\n            }\n            break;\n          case TokenizerStates.TRUE2:\n            if (n === charset.LATIN_SMALL_LETTER_U) {\n              this.state = TokenizerStates.TRUE3;\n              continue;\n            }\n            break;\n          case TokenizerStates.TRUE3:\n            if (n === charset.LATIN_SMALL_LETTER_E) {\n              this.state = TokenizerStates.START;\n              this.onToken({\n                token: TokenType.TRUE,\n                value: true,\n                offset: this.offset,\n              });\n              this.offset += 3;\n              continue;\n            }\n            break;\n          // FALSE\n          case TokenizerStates.FALSE1:\n            if (n === charset.LATIN_SMALL_LETTER_A) {\n              this.state = TokenizerStates.FALSE2;\n              continue;\n            }\n            break;\n          case TokenizerStates.FALSE2:\n            if (n === charset.LATIN_SMALL_LETTER_L) {\n              this.state = TokenizerStates.FALSE3;\n              continue;\n            }\n            break;\n          case TokenizerStates.FALSE3:\n            if (n === charset.LATIN_SMALL_LETTER_S) {\n              this.state = TokenizerStates.FALSE4;\n              continue;\n            }\n            break;\n          case TokenizerStates.FALSE4:\n            if (n === charset.LATIN_SMALL_LETTER_E) {\n              this.state = TokenizerStates.START;\n              this.onToken({\n                token: TokenType.FALSE,\n                value: false,\n                offset: this.offset,\n              });\n              this.offset += 4;\n              continue;\n            }\n            break;\n          // NULL\n          case TokenizerStates.NULL1:\n            if (n === charset.LATIN_SMALL_LETTER_U) {\n              this.state = TokenizerStates.NULL2;\n              continue;\n            }\n            break;\n          case TokenizerStates.NULL2:\n            if (n === charset.LATIN_SMALL_LETTER_L) {\n              this.state = TokenizerStates.NULL3;\n              continue;\n            }\n            break;\n          case TokenizerStates.NULL3:\n            if (n === charset.LATIN_SMALL_LETTER_L) {\n              this.state = TokenizerStates.START;\n              this.onToken({\n                token: TokenType.NULL,\n                value: null,\n                offset: this.offset,\n              });\n              this.offset += 3;\n              continue;\n            }\n            break;\n          case TokenizerStates.SEPARATOR:\n            this.separatorIndex += 1;\n            if (\n              !this.separatorBytes ||\n              n !== this.separatorBytes[this.separatorIndex]\n            ) {\n              break;\n            }\n            if (this.separatorIndex === this.separatorBytes.length - 1) {\n              this.state = TokenizerStates.START;\n              this.onToken({\n                token: TokenType.SEPARATOR,\n                value: this.separator as string,\n                offset: this.offset + this.separatorIndex,\n              });\n              this.separatorIndex = 0;\n            }\n            continue;\n          // BOM support\n          case TokenizerStates.BOM:\n            if (n === this.bom![this.bomIndex]) {\n              if (this.bomIndex === this.bom!.length - 1) {\n                this.state = TokenizerStates.START;\n                this.bom = undefined;\n                this.bomIndex = 0;\n                continue;\n              }\n              this.bomIndex += 1;\n              continue;\n            }\n            break;\n          case TokenizerStates.ENDED:\n            if (\n              n === charset.SPACE ||\n              n === charset.NEWLINE ||\n              n === charset.CARRIAGE_RETURN ||\n              n === charset.TAB\n            ) {\n              // whitespace\n              continue;\n            }\n        }\n\n        throw new TokenizerError(\n          `Unexpected \"${String.fromCharCode(\n            n,\n          )}\" at position \"${i}\" in state ${TokenizerStateToString(\n            this.state,\n          )}`,\n        );\n      }\n\n      if (this.emitPartialTokens) {\n        switch (this.state) {\n          case TokenizerStates.TRUE1:\n          case TokenizerStates.TRUE2:\n          case TokenizerStates.TRUE3:\n            this.onToken({\n              token: TokenType.TRUE,\n              value: true,\n              offset: this.offset,\n              partial: true,\n            });\n            break;\n          case TokenizerStates.FALSE1:\n          case TokenizerStates.FALSE2:\n          case TokenizerStates.FALSE3:\n          case TokenizerStates.FALSE4:\n            this.onToken({\n              token: TokenType.FALSE,\n              value: false,\n              offset: this.offset,\n              partial: true,\n            });\n            break;\n          case TokenizerStates.NULL1:\n          case TokenizerStates.NULL2:\n          case TokenizerStates.NULL3:\n            this.onToken({\n              token: TokenType.NULL,\n              value: null,\n              offset: this.offset,\n              partial: true,\n            });\n            break;\n          case TokenizerStates.STRING_DEFAULT: {\n            const string = this.bufferedString.toString();\n            this.onToken({\n              token: TokenType.STRING,\n              value: string,\n              offset: this.offset,\n              partial: true,\n            });\n            break;\n          }\n          case TokenizerStates.NUMBER_AFTER_INITIAL_ZERO:\n          case TokenizerStates.NUMBER_AFTER_INITIAL_NON_ZERO:\n          case TokenizerStates.NUMBER_AFTER_DECIMAL:\n          case TokenizerStates.NUMBER_AFTER_E_AND_DIGIT:\n            try {\n              this.onToken({\n                token: TokenType.NUMBER,\n                value: this.parseNumber(this.bufferedNumber.toString()),\n                offset: this.offset,\n                partial: true,\n              });\n            } catch (err: unknown) {\n              // Number couldn't be parsed. Do nothing.\n            }\n        }\n      }\n    } catch (err: any) {\n      this.error(err);\n    }\n  }\n\n  private emitNumber(): void {\n    this.onToken({\n      token: TokenType.NUMBER,\n      value: this.parseNumber(this.bufferedNumber.toString()),\n      offset: this.offset,\n    });\n    this.offset += this.bufferedNumber.byteLength - 1;\n  }\n\n  protected parseNumber(numberStr: string): number {\n    return Number(numberStr);\n  }\n\n  public error(err: Error): void {\n    if (this.state !== TokenizerStates.ENDED) {\n      this.state = TokenizerStates.ERROR;\n    }\n\n    this.onError(err);\n  }\n\n  public end(): void {\n    switch (this.state) {\n      case TokenizerStates.NUMBER_AFTER_INITIAL_ZERO:\n      case TokenizerStates.NUMBER_AFTER_INITIAL_NON_ZERO:\n      case TokenizerStates.NUMBER_AFTER_DECIMAL:\n      case TokenizerStates.NUMBER_AFTER_E_AND_DIGIT:\n        this.state = TokenizerStates.ENDED;\n        this.emitNumber();\n        this.onEnd();\n        break;\n      case TokenizerStates.BOM_OR_START:\n      case TokenizerStates.START:\n      case TokenizerStates.ERROR:\n      case TokenizerStates.SEPARATOR:\n        this.state = TokenizerStates.ENDED;\n        this.onEnd();\n        break;\n      default:\n        this.error(\n          new TokenizerError(\n            `Tokenizer ended in the middle of a token (state: ${TokenizerStateToString(\n              this.state,\n            )}). Either not all the data was received or the data was invalid.`,\n          ),\n        );\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public onToken(parsedToken: ParsedTokenInfo): void {\n    // Override me\n    throw new TokenizerError(\n      'Can\\'t emit tokens before the \"onToken\" callback has been set up.',\n    );\n  }\n\n  public onError(err: Error): void {\n    // Override me\n    throw err;\n  }\n\n  public onEnd(): void {\n    // Override me\n  }\n}\n", "import type { JsonKey, JsonStruct } from \"./jsonTypes.js\";\n\nexport const enum TokenParserMode {\n  OBJECT,\n  ARRAY,\n}\n\nexport interface StackElement {\n  key: JsonKey;\n  value: JsonStruct;\n  mode?: TokenParserMode;\n  emit: boolean;\n}\n", "import TokenType from \"./utils/types/tokenType.js\";\nimport type {\n  JsonPrimitive,\n  JsonKey,\n  JsonObject,\n  JsonArray,\n  JsonStruct,\n} from \"./utils/types/jsonTypes.js\";\nimport {\n  type StackElement,\n  TokenParserMode,\n} from \"./utils/types/stackElement.js\";\nimport type { ParsedTokenInfo } from \"./utils/types/parsedTokenInfo.js\";\nimport type { ParsedElementInfo } from \"./utils/types/parsedElementInfo.js\";\n\n// Parser States\nconst enum TokenParserState {\n  VALUE,\n  KEY,\n  COLON,\n  COMMA,\n  ENDED,\n  ERROR,\n  SEPARATOR,\n}\n\nfunction TokenParserStateToString(state: TokenParserState): string {\n  return [\"VALUE\", \"KEY\", \"COLON\", \"COMMA\", \"ENDED\", \"ERROR\", \"SEPARATOR\"][\n    state\n  ];\n}\n\nexport interface TokenParserOptions {\n  paths?: string[];\n  keepStack?: boolean;\n  separator?: string;\n  emitPartialValues?: boolean;\n}\n\nconst defaultOpts: TokenParserOptions = {\n  paths: undefined,\n  keepStack: true,\n  separator: undefined,\n  emitPartialValues: false,\n};\n\nexport class TokenParserError extends Error {\n  constructor(message: string) {\n    super(message);\n    // Typescript is broken. This is a workaround\n    Object.setPrototypeOf(this, TokenParserError.prototype);\n  }\n}\n\nexport default class TokenParser {\n  private readonly paths?: (string[] | undefined)[];\n  private readonly keepStack: boolean;\n  private readonly separator?: string;\n  private state: TokenParserState = TokenParserState.VALUE;\n  private mode: TokenParserMode | undefined = undefined;\n  private key: JsonKey = undefined;\n  private value: JsonStruct | undefined = undefined;\n  private stack: StackElement[] = [];\n\n  constructor(opts?: TokenParserOptions) {\n    opts = { ...defaultOpts, ...opts };\n\n    if (opts.paths) {\n      this.paths = opts.paths.map((path) => {\n        if (path === undefined || path === \"$*\") return undefined;\n\n        if (!path.startsWith(\"$\"))\n          throw new TokenParserError(\n            `Invalid selector \"${path}\". Should start with \"$\".`,\n          );\n        const pathParts = path.split(\".\").slice(1);\n        if (pathParts.includes(\"\"))\n          throw new TokenParserError(\n            `Invalid selector \"${path}\". \"..\" syntax not supported.`,\n          );\n        return pathParts;\n      });\n    }\n\n    this.keepStack = opts.keepStack || false;\n    this.separator = opts.separator;\n    if (!opts.emitPartialValues) {\n      this.emitPartial = () => {};\n    }\n  }\n\n  private shouldEmit(): boolean {\n    if (!this.paths) return true;\n\n    return this.paths.some((path) => {\n      if (path === undefined) return true;\n      if (path.length !== this.stack.length) return false;\n\n      for (let i = 0; i < path.length - 1; i++) {\n        const selector = path[i];\n        const key = this.stack[i + 1].key;\n        if (selector === \"*\") continue;\n        if (selector !== key) return false;\n      }\n\n      const selector = path[path.length - 1];\n      if (selector === \"*\") return true;\n      return selector === this.key?.toString();\n    });\n  }\n\n  private push(): void {\n    this.stack.push({\n      key: this.key,\n      value: this.value as JsonStruct,\n      mode: this.mode,\n      emit: this.shouldEmit(),\n    });\n  }\n\n  private pop(): void {\n    const value = this.value;\n\n    let emit;\n    ({\n      key: this.key,\n      value: this.value,\n      mode: this.mode,\n      emit,\n    } = this.stack.pop() as StackElement);\n\n    this.state =\n      this.mode !== undefined ? TokenParserState.COMMA : TokenParserState.VALUE;\n\n    this.emit(value as JsonPrimitive | JsonStruct, emit);\n  }\n\n  private emit(value: JsonPrimitive | JsonStruct, emit: boolean): void {\n    if (\n      !this.keepStack &&\n      this.value &&\n      this.stack.every((item) => !item.emit)\n    ) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      delete (this.value as JsonStruct as any)[this.key as string | number];\n    }\n\n    if (emit) {\n      this.onValue({\n        value: value,\n        key: this.key,\n        parent: this.value,\n        stack: this.stack,\n      });\n    }\n\n    if (this.stack.length === 0) {\n      if (this.separator) {\n        this.state = TokenParserState.SEPARATOR;\n      } else if (this.separator === undefined) {\n        this.end();\n      }\n      // else if separator === '', expect next JSON object.\n    }\n  }\n\n  private emitPartial(value?: JsonPrimitive): void {\n    if (!this.shouldEmit()) return;\n\n    if (this.state === TokenParserState.KEY) {\n      this.onValue({\n        value: undefined,\n        key: value as JsonKey,\n        parent: this.value,\n        stack: this.stack,\n        partial: true,\n      });\n      return;\n    }\n\n    this.onValue({\n      value: value,\n      key: this.key,\n      parent: this.value,\n      stack: this.stack,\n      partial: true,\n    });\n  }\n\n  public get isEnded(): boolean {\n    return this.state === TokenParserState.ENDED;\n  }\n\n  public write({\n    token,\n    value,\n    partial,\n  }: Omit<ParsedTokenInfo, \"offset\">): void {\n    try {\n      if (partial) {\n        this.emitPartial(value);\n        return;\n      }\n\n      if (this.state === TokenParserState.VALUE) {\n        if (\n          token === TokenType.STRING ||\n          token === TokenType.NUMBER ||\n          token === TokenType.TRUE ||\n          token === TokenType.FALSE ||\n          token === TokenType.NULL\n        ) {\n          if (this.mode === TokenParserMode.OBJECT) {\n            (this.value as JsonObject)[this.key as string] = value;\n            this.state = TokenParserState.COMMA;\n          } else if (this.mode === TokenParserMode.ARRAY) {\n            (this.value as JsonArray).push(value);\n            this.state = TokenParserState.COMMA;\n          }\n\n          this.emit(value, this.shouldEmit());\n          return;\n        }\n\n        if (token === TokenType.LEFT_BRACE) {\n          this.push();\n          if (this.mode === TokenParserMode.OBJECT) {\n            this.value = (this.value as JsonObject)[this.key as string] = {};\n          } else if (this.mode === TokenParserMode.ARRAY) {\n            const val = {};\n            (this.value as JsonArray).push(val);\n            this.value = val;\n          } else {\n            this.value = {};\n          }\n          this.mode = TokenParserMode.OBJECT;\n          this.state = TokenParserState.KEY;\n          this.key = undefined;\n          this.emitPartial();\n          return;\n        }\n\n        if (token === TokenType.LEFT_BRACKET) {\n          this.push();\n          if (this.mode === TokenParserMode.OBJECT) {\n            this.value = (this.value as JsonObject)[this.key as string] = [];\n          } else if (this.mode === TokenParserMode.ARRAY) {\n            const val: JsonArray = [];\n            (this.value as JsonArray).push(val);\n            this.value = val;\n          } else {\n            this.value = [];\n          }\n          this.mode = TokenParserMode.ARRAY;\n          this.state = TokenParserState.VALUE;\n          this.key = 0;\n          this.emitPartial();\n          return;\n        }\n\n        if (\n          this.mode === TokenParserMode.ARRAY &&\n          token === TokenType.RIGHT_BRACKET &&\n          (this.value as JsonArray).length === 0\n        ) {\n          this.pop();\n          return;\n        }\n      }\n\n      if (this.state === TokenParserState.KEY) {\n        if (token === TokenType.STRING) {\n          this.key = value as string;\n          this.state = TokenParserState.COLON;\n          this.emitPartial();\n          return;\n        }\n\n        if (\n          token === TokenType.RIGHT_BRACE &&\n          Object.keys(this.value as JsonObject).length === 0\n        ) {\n          this.pop();\n          return;\n        }\n      }\n\n      if (this.state === TokenParserState.COLON) {\n        if (token === TokenType.COLON) {\n          this.state = TokenParserState.VALUE;\n          return;\n        }\n      }\n\n      if (this.state === TokenParserState.COMMA) {\n        if (token === TokenType.COMMA) {\n          if (this.mode === TokenParserMode.ARRAY) {\n            this.state = TokenParserState.VALUE;\n            (this.key as number) += 1;\n            return;\n          }\n\n          /* istanbul ignore else */\n          if (this.mode === TokenParserMode.OBJECT) {\n            this.state = TokenParserState.KEY;\n            return;\n          }\n        }\n\n        if (\n          (token === TokenType.RIGHT_BRACE &&\n            this.mode === TokenParserMode.OBJECT) ||\n          (token === TokenType.RIGHT_BRACKET &&\n            this.mode === TokenParserMode.ARRAY)\n        ) {\n          this.pop();\n          return;\n        }\n      }\n\n      if (this.state === TokenParserState.SEPARATOR) {\n        if (token === TokenType.SEPARATOR && value === this.separator) {\n          this.state = TokenParserState.VALUE;\n          return;\n        }\n      }\n\n      throw new TokenParserError(\n        `Unexpected ${TokenType[token]} (${JSON.stringify(\n          value,\n        )}) in state ${TokenParserStateToString(this.state)}`,\n      );\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (err: any) {\n      this.error(err);\n    }\n  }\n\n  public error(err: Error): void {\n    if (this.state !== TokenParserState.ENDED) {\n      this.state = TokenParserState.ERROR;\n    }\n\n    this.onError(err);\n  }\n\n  public end(): void {\n    if (\n      (this.state !== TokenParserState.VALUE &&\n        this.state !== TokenParserState.SEPARATOR) ||\n      this.stack.length > 0\n    ) {\n      this.error(\n        new Error(\n          `Parser ended in mid-parsing (state: ${TokenParserStateToString(\n            this.state,\n          )}). Either not all the data was received or the data was invalid.`,\n        ),\n      );\n    } else {\n      this.state = TokenParserState.ENDED;\n      this.onEnd();\n    }\n  }\n\n  /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n  public onValue(parsedElementInfo: ParsedElementInfo): void {\n    // Override me\n    throw new TokenParserError(\n      'Can\\'t emit data before the \"onValue\" callback has been set up.',\n    );\n  }\n\n  public onError(err: Error): void {\n    // Override me\n    throw err;\n  }\n\n  public onEnd(): void {\n    // Override me\n  }\n}\n", "export {};\n//# sourceMappingURL=jsonTypes.js.map", "import TokenType from \"./tokenType.js\";\nimport type { JsonPrimitive } from \"./jsonTypes.js\";\n\nexport interface ParsedTokenInfo {\n  token: TokenType;\n  value: JsonPrimitive;\n  offset: number;\n  partial?: boolean;\n}\n\nexport interface ParsedLeftBraceTokenInfo extends ParsedTokenInfo {\n  token: TokenType.LEFT_BRACE;\n  value: \"{\";\n}\nexport interface ParsedRightBraceTokenInfo extends ParsedTokenInfo {\n  token: TokenType.RIGHT_BRACE;\n  value: \"}\";\n}\nexport interface ParsedLeftBracketTokenInfo extends ParsedTokenInfo {\n  token: TokenType.LEFT_BRACKET;\n  value: \"[\";\n}\nexport interface ParsedRighBracketTokenInfo extends ParsedTokenInfo {\n  token: TokenType.RIGHT_BRACKET;\n  value: \"]\";\n}\nexport interface ParsedColonTokenInfo extends ParsedTokenInfo {\n  token: TokenType.COLON;\n  value: \":\";\n}\nexport interface ParsedCommaTokenInfo extends ParsedTokenInfo {\n  token: TokenType.COMMA;\n  value: \",\";\n}\nexport interface ParsedTrueTokenInfo extends ParsedTokenInfo {\n  token: TokenType.TRUE;\n  value: true;\n}\nexport interface ParsedFalseTokenInfo extends ParsedTokenInfo {\n  token: TokenType.FALSE;\n  value: false;\n}\nexport interface ParsedNullTokenInfo extends ParsedTokenInfo {\n  token: TokenType.NULL;\n  value: null;\n}\nexport interface ParsedStringTokenInfo extends ParsedTokenInfo {\n  token: TokenType.STRING;\n  value: string;\n}\nexport interface ParsedNumberTokenInfo extends ParsedTokenInfo {\n  token: TokenType.NUMBER;\n  value: number;\n}\nexport interface ParsedSeparatorTokenInfo extends ParsedTokenInfo {\n  token: TokenType.SEPARATOR;\n  value: string;\n}\n", "export {};\n//# sourceMappingURL=parsedElementInfo.js.map", "import {\n  Tokenizer,\n  TokenParser,\n  TokenType,\n  TokenizerError,\n} from '@streamparser/json';\nimport JSON2CSVBase, {\n  type Json2CSVBaseOptions,\n  type NormalizedJson2CSVBaseOptions,\n} from './BaseParser.js';\n\nexport interface StreamParserOptions {\n  objectMode?: boolean;\n  stringBufferSize?: number;\n  numberBufferSize?: number;\n}\n\ninterface ObjectModeTokenizer<TRaw> {\n  isEnded?: boolean;\n  write: (data: TRaw) => void;\n  end: () => void;\n}\n\nexport default class JSON2CSVStreamParser<\n  TRaw extends object,\n  T extends object,\n> extends JSON2CSVBase<TRaw, T> {\n  protected tokenizer!: Tokenizer | ObjectModeTokenizer<TRaw>;\n  private tokenParser!: TokenParser;\n  private _hasWritten = false;\n\n  constructor(\n    opts?: Readonly<Json2CSVBaseOptions<TRaw, T>>,\n    asyncOpts?: Readonly<StreamParserOptions>,\n  ) {\n    super(opts);\n    if (this.opts.fields)\n      this.preprocessFieldsInfo(this.opts.fields, this.opts.defaultValue);\n    this.initTokenizer(this.opts, asyncOpts);\n  }\n\n  protected initTokenizer(\n    opts: NormalizedJson2CSVBaseOptions<TRaw, T>,\n    asyncOpts: StreamParserOptions = {},\n  ) {\n    if (asyncOpts.objectMode) {\n      this.tokenizer = this.getObjectModeTokenizer();\n      return;\n    }\n\n    if (opts.ndjson) {\n      this.tokenizer = this.getNdJsonTokenizer(asyncOpts);\n      return;\n    }\n\n    this.tokenizer = this.getBinaryModeTokenizer(asyncOpts);\n    return;\n  }\n\n  protected getObjectModeTokenizer(): ObjectModeTokenizer<TRaw> {\n    return {\n      write: (data) => this.pushLine(data),\n      end: () => {\n        this.pushHeaderIfNotWritten();\n        this.onEnd();\n      },\n    };\n  }\n\n  private configureCallbacks(tokenizer: Tokenizer, tokenParser: TokenParser) {\n    tokenizer.onToken = tokenParser.write.bind(this.tokenParser);\n    tokenizer.onError = (err) => this.onError(err);\n    tokenizer.onEnd = () => {\n      if (!this.tokenParser.isEnded) this.tokenParser.end();\n    };\n\n    tokenParser.onValue = ({ value }) => this.pushLine(value as TRaw);\n    tokenParser.onError = (err) => this.onError(err);\n    tokenParser.onEnd = () => {\n      this.pushHeaderIfNotWritten();\n      this.onEnd();\n    };\n  }\n\n  protected getNdJsonTokenizer(asyncOpts: StreamParserOptions): Tokenizer {\n    const tokenizer = new Tokenizer({ ...asyncOpts, separator: this.opts.eol });\n    this.tokenParser = new TokenParser({\n      paths: ['$'],\n      keepStack: false,\n      separator: this.opts.eol,\n    });\n    this.configureCallbacks(tokenizer, this.tokenParser);\n    return tokenizer;\n  }\n\n  protected getBinaryModeTokenizer(asyncOpts: StreamParserOptions): Tokenizer {\n    const tokenizer = new Tokenizer(asyncOpts);\n    tokenizer.onToken = ({ token, value }) => {\n      if (token === TokenType.LEFT_BRACKET) {\n        this.tokenParser = new TokenParser({\n          paths: ['$.*'],\n          keepStack: false,\n        });\n      } else if (token === TokenType.LEFT_BRACE) {\n        this.tokenParser = new TokenParser({ paths: ['$'], keepStack: false });\n      } else {\n        this.onError(\n          new Error(\n            'Data items should be objects or the \"fields\" option should be included',\n          ),\n        );\n        return;\n      }\n\n      this.configureCallbacks(tokenizer, this.tokenParser);\n\n      this.tokenParser.write({ token, value });\n    };\n    tokenizer.onError = (err) =>\n      this.onError(\n        err instanceof TokenizerError\n          ? new Error('Data should be a valid JSON object or array')\n          : err,\n      );\n    tokenizer.onEnd = () => {\n      this.pushHeaderIfNotWritten();\n      this.onEnd();\n    };\n\n    return tokenizer;\n  }\n\n  // TODO this should be narrowed based on options\n  write(data: Iterable<number> | string | TRaw): void {\n    this.tokenizer.write(data as any);\n  }\n\n  end() {\n    if (this.tokenizer && !this.tokenizer.isEnded) this.tokenizer.end();\n  }\n\n  pushHeaderIfNotWritten() {\n    if (this._hasWritten) return;\n    if (!this.opts.fields) {\n      this.onError(\n        new Error(\n          'Data should not be empty or the \"fields\" option should be included',\n        ),\n      );\n      return;\n    }\n\n    this.pushHeader();\n  }\n\n  /**\n   * Generate the csv header and pushes it downstream.\n   */\n  pushHeader() {\n    if (this.opts.withBOM) {\n      this.onData('\\ufeff');\n    }\n\n    if (this.opts.header) {\n      const header = this.getHeader();\n      this.onHeader(header);\n      this.onData(header);\n      this._hasWritten = true;\n    }\n  }\n\n  /**\n   * Transforms an incoming json data to csv and pushes it downstream.\n   *\n   * @param {Object} data JSON object to be converted in a CSV row\n   */\n  pushLine(data: TRaw) {\n    const processedData = this.preprocessRow(data);\n\n    if (!this._hasWritten) {\n      if (!this.opts.fields) {\n        if (typeof processedData[0] !== 'object') {\n          throw new Error(\n            'Data items should be objects or the \"fields\" option should be included',\n          );\n        }\n        this.opts.fields = this.preprocessFieldsInfo(\n          Object.keys(processedData[0]),\n          this.opts.defaultValue,\n        );\n      }\n      this.pushHeader();\n    }\n\n    processedData.forEach((row) => {\n      const line = this.processRow(row);\n      if (line === undefined) return;\n      this.onLine(line);\n      this.onData(this._hasWritten ? this.opts.eol + line : line);\n      this._hasWritten = true;\n    });\n  }\n\n  // No idea why eslint doesn't detect the usage of these\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  /* c8 ignore start */\n  onHeader(header: string) {\n    /* To be set by the user */\n  }\n  onLine(line: string) {\n    /* To be set by the user */\n  }\n  onData(data: string) {\n    /* To be set by the user */\n  }\n  onError(err: Error) {\n    /* To be set by the user */\n  }\n  onEnd() {\n    /* To be set by the user */\n  }\n  /* c8 ignore stop */\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n}\n"],
  "mappings": "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,EAAAA,SAAAA,SAAA,eAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,wBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,qBAAA,IAAA,EAAA,IAAA;A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",
  "names": ["quote", "quoteRegExp", "FormatterTypes", "stringFormatter", "objectFormatter", "row", "charset", "TokenType", "TokenizerStates", "TokenParserMode", "TokenParserState", "defaultOpts", "selector"]
}
